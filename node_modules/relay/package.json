{
  "_args": [
    [
      {
        "raw": "relay",
        "scope": null,
        "escapedName": "relay",
        "name": "relay",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\University\\Coursework"
    ]
  ],
  "_from": "relay@latest",
  "_id": "relay@0.8.0-1",
  "_inCache": true,
  "_location": "/relay",
  "_npmUser": {
    "name": "davidaurelio",
    "email": "dev@david-aurelio.com"
  },
  "_npmVersion": "1.2.14",
  "_phantomChildren": {},
  "_requested": {
    "raw": "relay",
    "scope": null,
    "escapedName": "relay",
    "name": "relay",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/relay/-/relay-0.8.0-1.tgz",
  "_shasum": "f2b632ea1be64bbe706c9351a99b27320ee89e07",
  "_shrinkwrap": null,
  "_spec": "relay",
  "_where": "C:\\University\\Coursework",
  "author": {
    "name": "David Aurelio",
    "email": "dev@david-aurelio.com"
  },
  "bugs": {
    "url": "https://github.com/davidaurelio/relay/issues"
  },
  "dependencies": {},
  "description": "relay offers three higher order functions to control flow of “node.js-style” functions – chain, combine and parallel.",
  "devDependencies": {
    "buster": "~0.6.12"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "f2b632ea1be64bbe706c9351a99b27320ee89e07",
    "tarball": "https://registry.npmjs.org/relay/-/relay-0.8.0-1.tgz"
  },
  "homepage": "https://github.com/davidaurelio/relay",
  "keywords": [
    "control",
    "flow",
    "asynchronous",
    "join",
    "parallel",
    "chain"
  ],
  "license": "MIT",
  "main": "relay.js",
  "maintainers": [
    {
      "name": "davidaurelio",
      "email": "dev@david-aurelio.com"
    }
  ],
  "name": "relay",
  "optionalDependencies": {},
  "readme": "relay – minimal control flow for asynchronous/continuation-style functions\n=====\n\n**relay** offers three higher order functions to control flow of “node.js-style” functions – `chain`, `combine` and `parallel`. It is well-tested, runs in browsers and node.js, and it’s very small.\n\n- The library works with functions that take “node-style” continuation callbacks as last argument, i.e. callbacks that expect an error or `null` as first argument, followed by values.\n- `chain` creates a function that executes all passed functions (“tasks”) consecutively, passing on the yielded values to the next task. The main callback is invoked with the values yielded by the last task or the first error.\n- `combine` creates a function that starts all passed tasks and invokes the main callback with all results after all tasks have finished or an error has been yielded.\n- `parallel` works like `combine`, but won’t stop after the first error. If any errors were yielded, the first argument of the main callback will be a (sparse) array of errors, where the index of the error corresponds to the order of tasks.\n- relay is tested in browsers (even IE6) and node.js. It should well work in other JS environments, too.\n- It has only 1067&#x202f;bytes minified, and 463&#x202f;bytes gzip’ed.\n\nUse it\n-----\n\nrelay.js (the file) is compatible with plain browser environments, node.js and AMD loaders. Just throw it into your project.\n\n```js\n// browser: just use the global variable\nrelay.chain(/* ... */);\n\n// node.js:\nvar relay = require('relay');\n\n// AMD loaders – no global will be defined\ndefine(['relay'], function(relay) { /* ... */ });\n```\n\nAPI\n-----\n\n### `chain(...task)(...arg, callback)`\n\n`chain` takes any number of functions (“tasks”) and returns a new function.\n\nWhen invoked, all tasks will be called consecutively, each recieving the values yielded by the previous task as arguments.\n\nThe created function takes any number of arguments (to be passed to the first task) and a callback function that will be executed with the values yielded by the last task **or the first error** yielded. Tasks must not call their callback more than once.\n\n`chain` is useful for a series of tasks, where each task needs the result of the previous task.\n\n#### Example\n\n```js\nvar avgPowers2_3 = chain(\n  function power2and3(base, callback) {\n    callback(null, base * base, base * base * base);\n  },\n  function add(a, b, callback) {\n    callback(null, a + b);\n  },\n  function half(a, callback) {\n    callback(null, a / 2);\n  });\n\nfunction log(error, result) { console.log(result); }\n\navgPowers2_3(2, log); // logs ‘6’\navgPowers2_3(3, log); // logs ‘18’\navgPowers2_3(4, log); // logs ‘40’\n```\n\n\n### `combine(...task)(...args, callback)`\n\n`combine` takes any number of functions (“tasks”) and returns a new function.\n\nWhen invoked, all tasks will be called immediately with arguments that may be passed to the wrapper function.\n\nThe created function takes any number of arrays (to apply to the tasks as arguments) and a callback function that will be executed with the values yielded by all tasks **or the first error** yielded. If a task yields multiple values, they will be wrapped in an array. If a task yields only one value, it will not be wrapped.\n\nTasks must not call their callback more than once.\n\n`combine` is useful when tasks don’t depend on each other, but the callback needs all values provided by the tasks.\n\n#### Example\n\n```js\n// see the chain example for avgPowers2_3.\n\nvar compute = combine(\n  // list tasks that take arguments first ...\n  avgPowers2_3,\n  function range(from, to, callback) {\n    if (to < from) { return callback(RangeError('Invalid range')); }\n    for (var result = [null]; from < to; from++) { result.push(from); }\n    callback.apply(null, result);\n  },\n  // ... and tasks without arguments last\n  function random(callback) {\n    callback(null, Math.random());\n  });\n\ncompute([5], // arguments for avgPowers2_3\n        [4, 8], // arguments for range\n        function callback(error, avg, range, random) {\n          console.log(avg, range, random);\n        });\n// logs “75 [ 4, 5, 6, 7 ] 0.5832999693229795”\n//                         ^^^^^^^^^^^^^^^^^^ value from last task\n//          ^^^^^^^^^^^^^^ values from second task as array\n//       ^^ value from first task\n\n\ncompute([5], [4, 3], function(error, avg, range, random) {\n  console.error(error, avg, range, random);\n});\n// logs “[RangeError: Invalid range] 75 undefined undefined”\n```\n\n### `parallel(...task)(...args, callback)`\n\n`parallel` takes any number of functions (“tasks”) and returns a new function. It works similar to `combine`, with the following exception:\n\nTasks yielding errors won’t short-circuit the invocation of the main callback. If any errors occur, the callback will receive a sparse array as first argument, containing all yielded errors according to\nthe task index, and all yielded values.\n\nTasks must not call their callback more than once.\n\n`parallel` is useful when tasks don’t depend on each other, and the main callback does not need all values.\n\n#### Example\n\n```js\n// see the chain example for avgPowers2_3.\n\nvar compute = parallel(\n  // list tasks that take arguments first ...\n  avgPowers2_3,\n  function range(from, to, callback) {\n    if (to < from) { return callback(RangeError('Invalid range')); }\n    for (var result = [null]; from < to; from++) { result.push(from); }\n    callback.apply(null, result);\n  },\n  // ... and tasks without arguments last\n  function random(callback) {\n    callback(null, Math.random());\n  });\n\ncompute([5], [4, 3], function(error, avg, range, random) {\n  console.error(error, avg, range, random);\n});\n// logs [ , [RangeError: Invalid range] ] 75 undefined 0.8862865746486932\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/davidaurelio/relay.git"
  },
  "scripts": {
    "test": "buster test -g node"
  },
  "version": "0.8.0-1"
}
